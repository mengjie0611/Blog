<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>常用前端面试参考总结 | mengjie前端开发</title>
    <meta name="description" content="一个努力的码农">
    <link rel="icon" type="image/x-icon" href="/Blog/img/icon.png">
    
    <link rel="preload" href="/Blog/assets/css/0.styles.edd67a01.css" as="style"><link rel="preload" href="/Blog/assets/js/app.2159d4b3.js" as="script"><link rel="preload" href="/Blog/assets/js/2.14622190.js" as="script"><link rel="preload" href="/Blog/assets/js/28.46f1bcdc.js" as="script"><link rel="prefetch" href="/Blog/assets/js/10.6a93ff19.js"><link rel="prefetch" href="/Blog/assets/js/11.c47f1757.js"><link rel="prefetch" href="/Blog/assets/js/12.73863227.js"><link rel="prefetch" href="/Blog/assets/js/13.80522e4d.js"><link rel="prefetch" href="/Blog/assets/js/14.68a4f5c6.js"><link rel="prefetch" href="/Blog/assets/js/15.ec00eb3a.js"><link rel="prefetch" href="/Blog/assets/js/16.f582d6c1.js"><link rel="prefetch" href="/Blog/assets/js/17.7b213757.js"><link rel="prefetch" href="/Blog/assets/js/18.b03270d5.js"><link rel="prefetch" href="/Blog/assets/js/19.e05d7c48.js"><link rel="prefetch" href="/Blog/assets/js/20.1bb272e3.js"><link rel="prefetch" href="/Blog/assets/js/21.5777fedf.js"><link rel="prefetch" href="/Blog/assets/js/22.89979eda.js"><link rel="prefetch" href="/Blog/assets/js/23.4b30007b.js"><link rel="prefetch" href="/Blog/assets/js/24.08c605af.js"><link rel="prefetch" href="/Blog/assets/js/25.3d0a8a58.js"><link rel="prefetch" href="/Blog/assets/js/26.07c0104b.js"><link rel="prefetch" href="/Blog/assets/js/27.24dfab8b.js"><link rel="prefetch" href="/Blog/assets/js/29.6dc6d7de.js"><link rel="prefetch" href="/Blog/assets/js/3.6c3dee68.js"><link rel="prefetch" href="/Blog/assets/js/30.dcce14df.js"><link rel="prefetch" href="/Blog/assets/js/4.8f84f249.js"><link rel="prefetch" href="/Blog/assets/js/5.236c83d5.js"><link rel="prefetch" href="/Blog/assets/js/6.ce0a3d40.js"><link rel="prefetch" href="/Blog/assets/js/7.44a5767d.js"><link rel="prefetch" href="/Blog/assets/js/8.e33d5460.js"><link rel="prefetch" href="/Blog/assets/js/9.102fdc46.js">
    <link rel="stylesheet" href="/Blog/assets/css/0.styles.edd67a01.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Blog/" class="home-link router-link-active"><img src="/Blog/img/logo.png" alt="mengjie前端开发" class="logo"> <span class="site-name can-hide">mengjie前端开发</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Blog/timeLine/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Blog/technology/" class="nav-link router-link-active">技术</a></div><div class="nav-item"><a href="/Blog/essay/" class="nav-link">随笔</a></div><div class="nav-item"><a href="/Blog/ponder/" class="nav-link">思考</a></div><div class="nav-item"><a href="/Blog/others/" class="nav-link">其他</a></div><div class="nav-item"><a href="/Blog/tags/" class="nav-link">标签</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/mengjie0611" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ES6入门
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav> <div class="mp3-player" data-v-172d32ba>
  音乐
  <div role="switch" class="el-switch" data-v-172d32ba><input type="checkbox" name="" true-value="true" class="el-switch__input"><!----><span class="el-switch__core" style="width:40px;"></span><!----></div> <audio loop="loop" data-v-172d32ba><source src="/Blog/assets/media/7 Years - Lukas Graham.e8dd8397.mp3" type="audio/mpeg" data-v-172d32ba></audio></div></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Blog/timeLine/" class="nav-link">首页</a></div><div class="nav-item"><a href="/Blog/technology/" class="nav-link router-link-active">技术</a></div><div class="nav-item"><a href="/Blog/essay/" class="nav-link">随笔</a></div><div class="nav-item"><a href="/Blog/ponder/" class="nav-link">思考</a></div><div class="nav-item"><a href="/Blog/others/" class="nav-link">其他</a></div><div class="nav-item"><a href="/Blog/tags/" class="nav-link">标签</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/mengjie0611" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ES6入门
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>常用前端面试参考总结</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#原型与原型链" class="sidebar-link">原型与原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#显式原型与隐式原型" class="sidebar-link">显式原型与隐式原型</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#原型链的属性问题" class="sidebar-link">原型链的属性问题</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#探索instanceof" class="sidebar-link">探索instanceof</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#面试题及总结" class="sidebar-link">面试题及总结</a></li></ul></li><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#webpack及构建工具的理解" class="sidebar-link">webpack及构建工具的理解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#构建工具的功能" class="sidebar-link">构建工具的功能</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#模块化打包和非模块化打包思想差异" class="sidebar-link">模块化打包和非模块化打包思想差异</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#webpack的核心概念" class="sidebar-link">webpack的核心概念</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#webpack的其他概念" class="sidebar-link">webpack的其他概念</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#webpack-和-gulp-的区别" class="sidebar-link">webpack 和 gulp 的区别</a></li></ul></li><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#客户端两种存储" class="sidebar-link">客户端两种存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#cookie存储" class="sidebar-link">Cookie存储</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#web-storage存储" class="sidebar-link">Web Storage存储</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#cookie存储和web-storage存储区别" class="sidebar-link">Cookie存储和Web Storage存储区别</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#存储方式的操作对比演示" class="sidebar-link">存储方式的操作对比演示</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#cookie-storage-session-关系" class="sidebar-link">cookie / storage / session 关系</a></li></ul></li><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#数组的一些方法" class="sidebar-link">数组的一些方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#数组去重" class="sidebar-link">数组去重</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#数组排序" class="sidebar-link">数组排序</a></li></ul></li><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#前端web-h5性能优化" class="sidebar-link">前端WEB/H5性能优化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#px-em-rem-区别" class="sidebar-link">px em rem 区别</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#实现一个jsonp请求" class="sidebar-link">实现一个jsonp请求</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#原型与原型链分析图例" class="sidebar-link">原型与原型链分析图例</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#实现类的继承" class="sidebar-link">实现类的继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#原型链的方法" class="sidebar-link">原型链的方法</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#class-类的方式" class="sidebar-link">class 类的方式</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#object-create-方法" class="sidebar-link">Object.create()方法</a></li><li class="sidebar-sub-header"><a href="/Blog/technology/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93.html#原型链-借用构造函数的组合继承" class="sidebar-link">原型链 + 借用构造函数的组合继承</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="常用前端面试参考总结"><a href="#常用前端面试参考总结" class="header-anchor">#</a> 常用前端面试参考总结</h1> <p>标签（空格分隔）： Summarize Interview</p> <hr> <h2 id="原型与原型链"><a href="#原型与原型链" class="header-anchor">#</a> 原型与原型链</h2> <h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <ul><li>函数的prototype属性(图)
<ul><li>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</li> <li>原型对象中有一个属性constructor, 它指向函数对象</li></ul></li> <li>给原型对象添加属性(一般都是方法)
<ul><li>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</li> <li>原型对象上的方法一般给其实例对象调用</li></ul></li></ul> <h3 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="header-anchor">#</a> 显式原型与隐式原型</h3> <ul><li>每个函数对象function都有一个prototype，即显式原型</li> <li>每个实例对象都有一个 <code>__proto__</code> ，可称为隐式原型</li> <li>对象的隐式原型的值为其对应构造函数的显式原型的值 ===&gt; 都指向函数对象</li> <li>内存结构(图)</li> <li>总结:
<ul><li>函数的prototype属性： 在定义函数时自动添加的，默认值是一个空Object对象</li> <li>对象的<code>__proto__</code>属性：创建对象时自动添加的，默认值为构造函数的prototype属性值</li> <li>程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)</li></ul></li> <li>举个例子</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// Fn()
var Fn = function () {}  // 执行这条函数定义语句, 函数体并没有执行

// 每个函数function都有一个prototype，即显式原型(属性)
console.log(Fn.prototype)

// 每个实例对象都有一个__proto__，可称为隐式原型(属性)
var fn = new Fn()
console.log(fn.__proto__)

// 对象的隐式原型的值为其对应构造函数的显式原型的值
console.log(fn.__proto__ === Fn.prototype)  // true

/*
 1. prototype属性: 函数对象
    什么时候添加? 函数被定义时(创建函数对象时自动添加)
    值是多少?  空的object实例对象: this.prototype = {}  this.prototype.constructor = this

2. __proto__属性: 实例对象
    什么时候添加? 创建实例对象时自动添加
    值是多少?   构造函数的prototype属性值: this.__proto__ = Fn.prototype
 */

/*
    执行函数: 执行函数体中的所有语句
    执行函数定义: 本质是创建函数对象
*/
console.log(Object.prototype.__proto__);  // null
</code></pre></div><h3 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h3> <ul><li>原型链(图解)</li> <li>访问一个对象的属性时，
<ul><li>先在自身属性中查找，找到返回</li> <li>如果没有,再沿着<code>__proto__</code>这条链向上查找, 找到返回</li> <li>如果最终没找到,返回undefined</li></ul></li> <li>别名：隐式原型链</li> <li>作用：<strong>查找对象的属性(方法)</strong></li> <li>构造函数/原型/实体对象的关系(图解)</li> <li>构造函数/原型/实体对象的关系2(图解)</li> <li>举个例子</li></ul> <div class="language- extra-class"><pre class="language-text"><code>console.log(Function.prototype===Function.__proto__)  // true
console.log(Object.prototype.__proto__)  // null
console.log(Object.prototype)
function Fn() {
    this.test1 = function () {
        console.log('test1()')
    }
}
Fn.prototype.test2 = function () {
    console.log('test2()')
}
var fn = new Fn()

fn.test1()
fn.test2()
console.log(fn.toString())
console.log(fn.test3)  // undefined
fn.test3()

// 详情请看githubMarkdownPhotos分析图
</code></pre></div><ul><li><strong>原型链总结</strong> <ul><li>查找对象的属性沿着原型链查找，查找变量沿着作用域链查找</li> <li>函数对象既有<code>prototype</code>属性，也有<code>__proto__</code>属性（函数的本质是被new出来的）</li> <li>所有函数对象的<code>__proto__</code>属性值都相等，都等于大写的Function的 <code>prototype</code></li> <li>所有函数都是Function的实例，包括它自己。
<code>Function.prototype === Function.__proto__ // true</code></li> <li>非函数对象（实例对象）肯定是其对应构造函数的实例</li></ul></li></ul> <h3 id="原型链的属性问题"><a href="#原型链的属性问题" class="header-anchor">#</a> 原型链的属性问题</h3> <ul><li>读取对象的属性值时: 会自动到原型链中查找</li> <li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li> <li>即：<strong>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</strong></li> <li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li> <li>举个例子</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.setName = function (name) {
    this.name = name;
}
Person.prototype.sex = '男';

var p1 = new Person('Tom', 12)
p1.setName('Jack')
console.log(p1.name, p1.age, p1.sex) // Jack 12 '男'

p1.sex = '女'  // 设置属性值时, 不会查看原型链
console.log(p1.name, p1.age, p1.sex) //Jack 12 '女'

var p2 = new Person('Bob', 23)
console.log(p2.name, p2.age, p2.sex) //'Bob' 23 '男'
</code></pre></div><h3 id="探索instanceof"><a href="#探索instanceof" class="header-anchor">#</a> 探索instanceof</h3> <ul><li>instanceof是如何判断的?
<ul><li>表达式: A instanceof B</li> <li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li> <li>A可以寻找多步，B只能找一步到自己的显式原型上</li></ul></li> <li>Function是通过new自己产生的实例。即所有函数都是Function的实例包括它自身。</li> <li>几点总结
<ul><li><code>Object created by Function</code></li> <li><code>Object 是 Function 的实例</code></li> <li><code>Object 是 Object 的实例</code></li></ul></li> <li>理解实例</li></ul> <div class="language- extra-class"><pre class="language-text"><code>console.log(Object instanceof Function) // true
console.log(Object instanceof Object) // true
console.log(Function instanceof Object) // true
console.log(Function instanceof Function) // true
console.log(Object instanceof Foo); // false

console.log(Function.prototype) // 不是Object的实例  ƒ () { [native code] }
console.log(Function.prototype.__proto__===Object.prototype) // true
</code></pre></div><ul><li>原型与原型链分析详图</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Foo () {}
var f1 = new Foo()
var f2 = new Foo()
var o1 = {}
var o2 = {}
</code></pre></div><p><img src="https://i.imgur.com/Q3nxgq6.png" alt="原型与原型链分析"></p> <h3 id="面试题及总结"><a href="#面试题及总结" class="header-anchor">#</a> 面试题及总结</h3> <div class="language- extra-class"><pre class="language-text"><code>// 测试题 1
var A = function() {}
A.prototype.n = 1
var b = new A()

A.prototype = {
    n: 2,
    m: 3
}
var c = new A()
console.log(b.n, b.m, c.n, c.m) //  1 undefined  2  3

// 测试题2
var F = function(){};
Object.prototype.a = function(){
    console.log('a()')
};
Function.prototype.b = function(){
    console.log('b()')
};
var f = new F();
f.a()     // a()
f.b()     // f.b is not a function
F.a()     // a()
F.b()     // b()


&lt;!--
原型链（隐式原型链）：作用查找对象的属性
    访问一个对象的属性时，先在自身属性中查找，找到返回；
    如果没有再沿着 __proto__ 这条链向上查找，找到返回，如果最终没有找到，则返回undefined

A instanceof B  的判断
    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false

prototype 与 __proto__ 在创建的时候相关联，在执行的时候没有关联
--&gt;
</code></pre></div><h2 id="webpack及构建工具的理解"><a href="#webpack及构建工具的理解" class="header-anchor">#</a> webpack及构建工具的理解</h2> <h3 id="构建工具的功能"><a href="#构建工具的功能" class="header-anchor">#</a> 构建工具的功能</h3> <ul><li><strong>代码转换</strong>：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。（开发写的代码有些浏览器无法识别，如ES6语法）</li> <li><strong>文件优化</strong>：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。（压缩代码）</li> <li><strong>模块合并</strong>：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li> <li><strong>代码分割</strong>：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li> <li><strong>自动刷新</strong>：监听本地源代码的变化，自动重新构建、刷新浏览器。 live reload 自动刷新 / hot reload 热模替换（HMR）（开发环境下修改代码后可以自动刷新浏览器看到最新的效果，可以监视源码的变化）</li> <li><strong>代码校验</strong>：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li></ul> <h3 id="模块化打包和非模块化打包思想差异"><a href="#模块化打包和非模块化打包思想差异" class="header-anchor">#</a> 模块化打包和非模块化打包思想差异</h3> <ul><li>非模块化打包：先对文件进行分类（如js/img/css等），然后分别打包</li> <li>模块化打包：将所有资源看成模块，而所有的模块之间都是有关系的，项目中的资源是相互关联的节点通过入口js形成一个网(图)的结构。
<ul><li>从入口开始递归的查找所有相关联的模块</li> <li>找到一个模块(如css)后会找对应的loader，模块文件会进行正则匹配的</li> <li>四个核心概念：entry | output | module(loader) | plugins</li> <li>loader模块加载器，将非js模块打包成webpack能理解的js模块</li> <li>图片处理推荐使用 <code>url-loader</code>，配置选项可以对图片进行限制，小于此限制的会会通过base64处理的</li></ul></li></ul> <h3 id="webpack的核心概念"><a href="#webpack的核心概念" class="header-anchor">#</a> webpack的核心概念</h3> <ul><li><strong>Entry</strong>：入口，Webpack进行打包的起始点(文件)</li> <li><strong>Output</strong>：出口，webpack编译打包生成的bundle(文件)</li> <li><strong>Loader</strong>：模块加载(转换)器，将非js模块包装成webpack能理解的js模块
<ul><li>（举例：如处理css要用到style-loader/css-loader;处理img使用file-loader/url-loader）</li></ul></li> <li><strong>Plugin</strong>：插件，在Webpack构建流程中的特定时机插入具有特定功能的代码
<ul><li>（举例：CleanPlugin一开始就会清除指定的文件/夹；</li> <li>ExtractTextPlugin用于样式的抽取，用来从js中分离出css并单独打包；</li> <li>CopyPlugin复制静态资源；</li> <li>webpack.HashedModuleIdsPlugin根据代码内容生成hash作为模块的id(默认是下标)；</li> <li>webpack.optimize.CommonsChunkPlugin将第三方模块单独打包</li> <li>……）</li></ul></li> <li>Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件，如果是其它类型文件利用对应的loader转换为js模块</li> <li>Chunk：代码块，一个 Chunk 由多个模块组合而成，最终浏览器执行的是webpack打包生成的chunk文件(bundle同理)</li></ul> <h3 id="webpack的其他概念"><a href="#webpack的其他概念" class="header-anchor">#</a> webpack的其他概念</h3> <ul><li><img src="http://static.zybuluo.com/MarlonChiu/12qcvudloms3ft00fsxugjtt/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_1.png" alt="webpack其它概念_1.png-39.4kB"></li> <li><img src="http://static.zybuluo.com/MarlonChiu/sxodezube6trrxitofbx3drp/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_2.png" alt="webpack其它概念_2.png-27.8kB"></li></ul> <h3 id="webpack-和-gulp-的区别"><a href="#webpack-和-gulp-的区别" class="header-anchor">#</a> webpack 和 gulp 的区别</h3> <ul><li>webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案；</li> <li>gulp 是工具链、构建工具，可以配合各种插件做 js 压缩，css压缩，less 编译替代手工实现自动化工作。</li> <li>Grunt/Gulp 更多的是一种工作流；提供集成所有服务的一站式平台； gulp可以用来优化前端工作流程。</li></ul> <h2 id="客户端两种存储"><a href="#客户端两种存储" class="header-anchor">#</a> 客户端两种存储</h2> <h3 id="cookie存储"><a href="#cookie存储" class="header-anchor">#</a> Cookie存储</h3> <div class="language- extra-class"><pre class="language-text"><code>Cookie是一项很老的技术的，就是因为它老，所以兼容性还是不错的。
使用Cookie作为本地存储优点：兼容性好，缺点：操作繁琐，只能存简单的数据，还会过期，站点设置httponly的话，JS就不无法操作Cookie了。
</code></pre></div><h3 id="web-storage存储"><a href="#web-storage存储" class="header-anchor">#</a> Web Storage存储</h3> <div class="language- extra-class"><pre class="language-text"><code>WebStorage是HTML5中为WebApplication提供一种存储的API，目前主流的新版本的浏览器都支持，当然IE789你就没有办法了。WebStorage主要分成localStorage和sessionStorage两种。
</code></pre></div><h4 id="sessionstorage"><a href="#sessionstorage" class="header-anchor">#</a> sessionStorage</h4> <div class="language- extra-class"><pre class="language-text"><code>sessionStorage是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。
</code></pre></div><h4 id="localstorage"><a href="#localstorage" class="header-anchor">#</a> localStorage</h4> <div class="language- extra-class"><pre class="language-text"><code>localStorage也是一个全局变量，它的生命周期比sessionStorage长。localStorage和sessionStorage都继承自Storage因此它们的用法相同。
</code></pre></div><h4 id="webstorage的优点"><a href="#webstorage的优点" class="header-anchor">#</a> WebStorage的优点</h4> <div class="language- extra-class"><pre class="language-text"><code>使用简单方便，缺点：IE有些版本不支持，不能存复杂的对象，必须先转化成JSON字符串，没有索引搜索效率不高，只能同步读写操作，当写入的数据比较大时可能造成JS引擎堵塞。
</code></pre></div><h4 id="sessionstorage用法和localstorage区别"><a href="#sessionstorage用法和localstorage区别" class="header-anchor">#</a> sessionStorage用法和localStorage区别</h4> <div class="language- extra-class"><pre class="language-text"><code>完全一致，差别只在有效期：
sessionStorage在用户结束会话（即关闭浏览器或退出账户时失效）；
localStorage无失效期，用户在清理浏览器缓存的时候会被清除。
</code></pre></div><h3 id="cookie存储和web-storage存储区别"><a href="#cookie存储和web-storage存储区别" class="header-anchor">#</a> Cookie存储和Web Storage存储区别</h3> <div class="language- extra-class"><pre class="language-text"><code>localStorage与sessionStorage作为新时代的产物，相比旧时代的cookie有其巨大的优越性。优越性有三:
    其一在能存储的数据量，cookie最大能存储4kb的数据，而localStorage与sessionStorage最大能存储5Mb，目前各大浏览器支持的标准都是如此；
    
    其二在功能上，cookie只能存储String类型的数据，以往要将用户数据存储在本地，需要将数据拼接成字符串，再存进cookie,取数据的时候同样麻烦，先将整个cookie对象拿到（String对象），再按拼接的规则拆分，再拿需要的数据，存取都很麻烦！
    localStorage与sessionStorage不仅支持传统的String类型，还可以将json对象存储进去,存取数据都方便不少，json的优越性就不赘述，localStorage与sessionStorage无疑更现代化；
    
    其三是cookie是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在；而web storage仅仅是为了在本地‘存储’而生；
    其四在语义层面上，localStorage与sessionStorage语法更优雅、简便。
</code></pre></div><h3 id="存储方式的操作对比演示"><a href="#存储方式的操作对比演示" class="header-anchor">#</a> 存储方式的操作对比演示</h3> <div class="language- extra-class"><pre class="language-text"><code>// cookie的操作
设置cookie: document.cookie = 'key=value';
获取cookie: document.cookie;
删除cookie: document.cookie = &quot;key=value;max-age=0&quot;;
设置max-age存储期限: document.cookie = &quot;key=value;max-age=1000&quot;; // 1000秒

// web storage操作
保存数据 setItem(key,value)
读取数据 getItem(key)
删除单个数据 removeItem(key)
清空全部数据 clearItem()
获取数据索引 key(index)
</code></pre></div><h3 id="cookie-storage-session-关系"><a href="#cookie-storage-session-关系" class="header-anchor">#</a> cookie / storage / session 关系</h3> <ul><li><p>cookie</p> <ul><li>优点：可以解决http无状态问题</li> <li>缺点：
<ol><li>与服务器交互的时候有数量和长度限制 每个域名最多20条，长度不能超过4KB</li> <li>安全性问题 容易被人拦截</li> <li>浪费宽带，每次请求新页面，cookie都会被发过去</li> <li>不可以跨域</li></ol></li></ul></li> <li><p>cookie 和session区别</p> <ul><li>cookie是把数据放在客户的浏览器上，只能存储sting类型</li> <li>session数据是放在服务器上，能存储json 类型、sting类型</li> <li>session会在一定的时间内保留数据存在服务器上，当访问增多，
会比较占你服务器的性能 ，减轻服务器的性能 应当使用cookie</li> <li>sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，会话级别的存储</li> <li>localStorage持久存在，除非清除浏览器缓存。</li></ul></li></ul> <h2 id="数组的一些方法"><a href="#数组的一些方法" class="header-anchor">#</a> 数组的一些方法</h2> <h3 id="数组去重"><a href="#数组去重" class="header-anchor">#</a> 数组去重</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/*
1.先将原数组进行排序
2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因为已经排序，所以重复元素会在相邻位置
3.如果不相同，则将该元素存入结果数组中
*/</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">unique1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先排序</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> res<span class="token punctuation">[</span>res<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
  
<span class="token comment">/*
1.创建一个新的数组存放结果
2.创建一个空对象
3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，
  则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，
  并赋值为1，存入到第2步建立的对象中。
说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。
*/</span>
<span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">unique2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> json <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>json<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            json<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token string">'你好'</span><span class="token punctuation">,</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">112</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token string">'你好'</span><span class="token punctuation">,</span><span class="token string">'str'</span><span class="token punctuation">,</span><span class="token string">'str1'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// 方法零</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Set(7) {1, 7, 3, 4, 11, 2, 0}</span>
<span class="token comment">// 方法一</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">unique1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (7) [0, 1, 11, 2, 3, 4, 7]  按照Unicode排列了</span>
<span class="token comment">// 方法二</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">unique2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (7) [0, 1, 11, 2, 3, 4, 7]</span>
</code></pre></div><h3 id="数组排序"><a href="#数组排序" class="header-anchor">#</a> 数组排序</h3> <div class="language- extra-class"><pre class="language-text"><code>function quickSort(arr) {
  if(arr.length &lt;= 1){
    return arr;
  }
  // 基准索引（理论上可以任意选取）
  var pivotIndex = parseInt(arr.length/2),
    // 基准值
    pivot = arr.splice(pivotIndex,1)[0],
    leftArr = [],
    rightArr = [],
    length = arr.length;
  // 遍历序列，根据基准拆分为两个子序列
  for (var i = 0; i &lt; length; i++) {
    if(arr[i] &lt; pivot){
      leftArr.push(arr[i]);
    }else {
      rightArr.push(arr[i]);
    }
    
  }
  console.log(pivot); // 输出了三次 3 1 7
  
  // 连接左序列、基准、右序列
  return quickSort(leftArr).concat(pivot, quickSort(rightArr))
}
var demoArr = [8,4,7,2,0,3,1]

// 方法一
console.log(demoArr.sort()); // (7) [0, 1, 2, 3, 4, 7, 8]
// 方法二
console.log(quickSort(demoArr)) // (7) [0, 1, 2, 3, 4, 7, 8]
</code></pre></div><h2 id="前端web-h5性能优化"><a href="#前端web-h5性能优化" class="header-anchor">#</a> 前端WEB/H5性能优化</h2> <div class="language- extra-class"><pre class="language-text"><code>// 参考CSDN博客
http://blog.csdn.net/lpf1215/article/details/74315797?locationNum=8&amp;fps=1
</code></pre></div><ul><li>减少http请求，合理设置 HTTP缓存</li> <li>使用浏览器缓存</li> <li>启用压缩</li> <li>CSS Sprites</li> <li>LazyLoad Images</li> <li>CSS放在页面最上部，javascript放在页面最下面</li> <li>异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）</li> <li>减少cookie传输</li> <li>Javascript代码优化</li> <li>CSS选择符优化</li> <li>CDN加速</li> <li>反向代理</li></ul> <h2 id="px-em-rem-区别"><a href="#px-em-rem-区别" class="header-anchor">#</a> px em rem 区别</h2> <ul><li>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的</li> <li>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸</li> <li>rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素</li></ul> <h2 id="实现一个jsonp请求"><a href="#实现一个jsonp请求" class="header-anchor">#</a> 实现一个jsonp请求</h2> <div class="language- extra-class"><pre class="language-text"><code>&lt;script type=&quot;text/javascript&quot;&gt;
function jsonpCallback(result) {
    // alert(result);  
    for(var i in result) {
        alert(i+&quot;:&quot;+result[i]);// 循环输出a:1,b:2,etc.  
    }
}

var JSONP = document.createElement(&quot;script&quot;);
JSONP.type = &quot;text/javascript&quot;;
JSONP.src = &quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;;
document.getElementsByTagName(&quot;head&quot;)[0].appendChild(JSONP);
&lt;/script&gt;
</code></pre></div><h2 id="原型与原型链分析图例"><a href="#原型与原型链分析图例" class="header-anchor">#</a> 原型与原型链分析图例</h2> <ul><li>图例一
<img src="http://static.zybuluo.com/MarlonChiu/v5fxgw1c326yrmvru8gt4qxa/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_01.png" alt="原型链分析图例_01.png-35.1kB"></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 图例分析说明
</code></pre></div><ul><li>图例二
<img src="http://static.zybuluo.com/MarlonChiu/qj4jj2hpkqymby58zjazwl7x/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_02.png" alt="原型链分析图例_02.png-46.7kB"></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 图例分析说明
两个空间：栈和堆。在代码未执行之前，JS引擎就会先加载执行一些内置的代码就。在开始之前就先执行了Object定义（function Object(value){}），栈空间会有一个Object引用变量，传的是地址值0x123，开辟出一块空间，该空间就是Object函数对象，函数对象上有一个prototype属性，该属性也是引用类型，传递地址值0x234，开辟出一块新的空间，该空间指向Object原型对象，该Object原型对象的原型上包含hasOwnProperty、toString......等一些属性，也就说在代码执行之前第一列的关系已经存在了。

代码执行function Fn(){}，Fn指向的堆空间中一块区域，地址值为0x345，即Fn函数对象，Fn函数对象有一个prototype属性，该属性也是指向一块地址值0x456，指向Fn原型对象，该对象是一个空对象即{}。这个实例对象的__proto__又会指向Object的函数对象的prototype属性（实例对象的隐式原型等于函数对象的显示原型），地址值也是0x234，也会指向Object原型对象。
代码执行Fn.prototype.test2 则在Fn原型对象上添加test2()方法

代码执行var fn = new Fn()，fn的地址值为0x567，在堆内存中开辟空间指向Fn实例对象，该对象有隐式原型__proto__，其值是0x456，箭头指向Fn原型对象。Fn实例对象上有个方法test1()。


console.log(Function.prototype === Function.__proto__)  // true
console.log(Object.prototype.__proto__)  // null
console.log(Object.prototype.toString)  // ƒ toString() { [native code] }  Object原型上有toString方法
</code></pre></div><ul><li>图例三
<img src="http://static.zybuluo.com/MarlonChiu/2o4q7d8zguhokxee7b4avun1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_03.png" alt="原型与原型链分析图例_03.png-129.8kB"></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Foo() {
}
var f1 = new Foo()
var f2 = new Foo()
var o1 = {}
var o2 = {}
</code></pre></div><ul><li>图例四
<img src="http://static.zybuluo.com/MarlonChiu/4shqfy3qe573pw8t7fi70jpz/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90.png" alt="函数对象的原型分析.png-60.3kB"></li></ul> <h2 id="实现类的继承"><a href="#实现类的继承" class="header-anchor">#</a> 实现类的继承</h2> <h3 id="原型链的方法"><a href="#原型链的方法" class="header-anchor">#</a> 原型链的方法</h3> <ul><li>套路
<ol><li>定义父类型构造函数</li> <li>给父类型的原型添加方法</li> <li>定义子类型的构造函数</li> <li>创建父类型的对象赋值给子类型的原型</li> <li>将子类型原型的构造属性设置为子类型</li> <li>给子类型原型添加方法</li> <li>创建子类型的对象: 可以调用父类型的方法</li></ol></li> <li>关键
<ol><li>子类型的原型为父类型的一个实例对象
Child.prototype = new Parent()</li></ol></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Parent() {
    this.pProp = 'this Parent prop'
}
Parent.prototype.showPProp = function () {
    console.log('showPProp()', this.pProp)
}

function Child() {
    this.cProp = 'this Child prop'
}

// 让子类原型指向父类型实例
Child.prototype = new Parent()
// 让子类原型对象构造器属性指向子类
Child.prototype.constructor = Child

Child.prototype.showCProp = function () {
    console.log('showCProp()', this.cProp)
}

var child = new Child()
child.showPProp()
console.log(child.constructor) // ƒ Child() { this.cProp = 'this Child prop'}
console.log(child)   // Child {cProp: &quot;this Child prop&quot;}
</code></pre></div><h3 id="class-类的方式"><a href="#class-类的方式" class="header-anchor">#</a> class 类的方式</h3> <ul><li>通过class定义类/实现类的继承</li> <li>在类中通过constructor定义构造方法</li> <li>通过new来创建类的实例</li> <li>通过extends来实现类的继承</li> <li>通过super调用父类的构造方法</li> <li>重写从父类中继承的一般方法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 用class定义一个Person类
class Person{
    constructor (name, age){   // 类的构造方法
        this.name = name;
        this.age = age;
    }
    showName (){   // 类的一般方法
        console.log(this.name, this.age);
    }
}
let p1 = new Person(&quot;TOM&quot;, 18);
console.log(p1.name);
p1.showName();


// 定义一个Student 继承Person
class Student extends Person {  // 定义的Student类继承自Person类
    constructor (name, age, salary){
        super(name,age);  // 通过super调用父类的构造方法
        this.salary = salary;
    }
    showName (name, age, salary){
        console.log(this.name, this.age, this.salary);
    }
}
let s1 = new Student(&quot;MARLON&quot;, 26, 17000);
console.log(s1.name);
s1.showName();
</code></pre></div><h3 id="object-create-方法"><a href="#object-create-方法" class="header-anchor">#</a> Object.create()方法</h3> <ul><li><code>Object.create(prototype, [descriptors])</code> <ul><li>作用: 以指定对象为原型创建新的对象</li> <li>为新的对象指定新的属性, 并对属性进行描述
value : 指定值
writable : 标识当前属性值是否是可修改的, 默认为 false</li></ul></li> <li>用法演示</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//  Object.create(prototype, [descriptors])
var obj = {n:11};
var obj2 = Object.create(obj);
console.log(obj2, obj2.n);   // {} 11
var obj3 = Object.create(obj,{
    m: {
        value: &quot;asd&quot;,
        writable: false
    }
});
obj3.m = 456;
console.log(obj3.m);  // asd
</code></pre></div><h3 id="原型链-借用构造函数的组合继承"><a href="#原型链-借用构造函数的组合继承" class="header-anchor">#</a> 原型链 + 借用构造函数的组合继承</h3> <ul><li>利用原型链实现对父类型对象的方法继承</li> <li>利用call()借用父类型构建函数初始化相同属性</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Person(name, age) {
    this.name = name
    this.age = age
}
Person.prototype.setName = function (name) {
    this.name = name
}
function Student(name, age, price) { // 身价
    Person.call(this, name, age)  // 相当于: this.Person(name, age)
    this.price = price
}

Student.prototype = new Person()
Student.prototype.constructor = Student

Student.prototype.setPrice = function (price) {
    this.price = price
}

var s = new Student('Jack', 21, 13000)
s.setName('Bob')
s.setPrice(14000)
console.log(s.name, s.age, s.price)
</code></pre></div><hr></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/12/2021, 9:51:50 AM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/Blog/assets/js/app.2159d4b3.js" defer></script><script src="/Blog/assets/js/2.14622190.js" defer></script><script src="/Blog/assets/js/28.46f1bcdc.js" defer></script>
  </body>
</html>
